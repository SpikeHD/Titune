{
  "version": 3,
  "sources": ["util/meta.js", "util/options.js", "util/youtube.js", "util/radio.js", "util/audioController.js", "util/dialogs.js", "util/volume.js", "util/volumeFade.js", "index.js"],
  "sourcesContent": ["/**\n * We will have two URL params, the \"name\" and the \"id\". Name is used for embedding, ID is used for getting the playlist.\n *\n * The name will not matter, as its just for people reading the URL to identify the playlist (especially for embeding in sites and stuff).\n * The playlist ID does matter. Obviously.\n */\nexport function getRadioName() {\n    return new URLSearchParams(window.location.search).get('name');\n}\nexport function getPlaylistId() {\n    return new URLSearchParams(window.location.search).get('id');\n}\n", "export const qualityList = [\n    'AUDIO_QUALITY_ULTRALOW',\n    'AUDIO_QUALITY_LOW',\n    'AUDIO_QUALITY_MEDIUM',\n    'AUDIO_QUALITY_HIGH'\n];\nconst defaultOptions = {\n    invidiousInstance: 'https://vid.puffyan.us/',\n    shaders: true,\n    volume: 50,\n    preferredCodec: 'mp4a',\n    maxQuality: 'AUDIO_QUALITY_HIGH'\n};\nexport function getOptions() {\n    const options = localStorage.getItem('options');\n    return options ? JSON.parse(options) : defaultOptions;\n}\nexport function setOption(o, v) {\n    const options = getOptions();\n    options[o] = v;\n    localStorage.setItem('options', JSON.stringify(options));\n}\n", "import { getOptions, qualityList } from './options';\nimport { seedFromPlaylistId } from './radio';\nconst cachedPlaylistVideos = [];\nexport function playlistFromLink(link) {\n    const playlistId = link.match(/(?<=list=)[a-zA-Z0-9_-]+/)?.[0];\n    return playlistId;\n}\nexport async function playlistVideos(playlistId) {\n    // Check if we have a cached version of the playlist\n    if (cachedPlaylistVideos.length > 0) {\n        return cachedPlaylistVideos;\n    }\n    const inst = getOptions().invidiousInstance;\n    // Ensure URL ends with / if it doesn't already\n    const url = inst.endsWith('/') ? inst : inst + '/';\n    const result = (await fetch(`${url}api/v1/playlists/${playlistId}`).then(r => r.json()));\n    // Cache the playlist\n    cachedPlaylistVideos.push(...result.videos);\n    return result.videos;\n}\n/**\n * Get all of the audio sources for a given video\n */\nexport async function videoAudioSources(videoId) {\n    const inst = getOptions().invidiousInstance;\n    // Ensure URL ends with / if it doesn't already\n    const url = inst.endsWith('/') ? inst : inst + '/';\n    const result = (await fetch(`${url}api/v1/videos/${videoId}`).then(r => r.json())).adaptiveFormats;\n    return result.filter(r => r.type.startsWith('audio/'));\n}\n/**\n * Get the preferred audio source for a given video. If the preferred codec is not available, it will fall back to the first.\n */\nexport async function videoAudioSource(videoId) {\n    const sources = await videoAudioSources(videoId);\n    const { preferredCodec } = getOptions();\n    // Find the preferred codec\n    const codecPreferred = sources.filter(s => s.type.includes(preferredCodec));\n    // Within the preferred codec, find the audio source with the highest quality (within the maxQuality option)\n    const qualityPreferred = sourceWithClosestQuality(codecPreferred);\n    // If the preferred codec is not available, fall back to the first\n    return qualityPreferred || codecPreferred[0] || sources[0];\n}\n/**\n * Using the quality list, find the quality closest to the max quality, preferring lower before higher\n */\nexport function sourceWithClosestQuality(sources) {\n    const { maxQuality } = getOptions();\n    // Find the quality closest to the max quality, preferring lower before higher\n    const qualities = qualityList.filter(q => qualityList.indexOf(q) <= qualityList.indexOf(maxQuality)).sort((a, b) => qualityList.indexOf(a) - qualityList.indexOf(b));\n    const source = sources.find(s => qualities.some(q => s.audioQuality.includes(q)));\n    return source;\n}\nexport async function shuffledPlaylistVideos(playlistId) {\n    const videos = await playlistVideos(playlistId);\n    const seed = seedFromPlaylistId(playlistId);\n    const now = Date.now() / 1000;\n    // Get the total length of the playlist in seconds\n    const totalLength = videos.reduce((prev, curr) => prev + curr.lengthSeconds, 0);\n    // Create a modified seed using the total length of the playlist / the current time\n    // This makes it so that whenever the playlist is run through, it will be shuffled in a different way the next time\n    const dynSeed = Math.floor(now / totalLength) + seed;\n    return shuffle(videos, dynSeed);\n}\n/**\n * Fisher-Yates shuffle algorithm using the seed\n */\nexport function shuffle(array, seed) {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n        const j = Math.floor((seed + i) % (i + 1));\n        const temp = shuffled[i];\n        shuffled[i] = shuffled[j];\n        shuffled[j] = temp;\n    }\n    return shuffled;\n}\n", "import { shuffledPlaylistVideos } from './youtube';\n/**\n * Turn playlist id into a numeric 'seed'\n */\nexport function seedFromPlaylistId(playlistId) {\n    let seed = 0;\n    for (let i = 0; i < playlistId.length; i++) {\n        seed += playlistId.charCodeAt(i);\n    }\n    return seed;\n}\n/**\n * Get the current song and the time elapsed within it using a seed based on playlist ID and the current timestamp\n */\nexport async function getCurrentSong(playlistId) {\n    const songs = await shuffledPlaylistVideos(playlistId);\n    const now = Date.now();\n    // Get the total length of all songs\n    let totalLength = 0;\n    for (const song of songs) {\n        totalLength += song.lengthSeconds;\n    }\n    // Get the current time elapsed\n    const elapsed = Math.floor((now / 1000) % totalLength);\n    // Get the current song\n    let currentLength = 0;\n    let song;\n    for (const s of songs) {\n        currentLength += s.lengthSeconds;\n        if (elapsed < currentLength) {\n            song = s;\n            break;\n        }\n    }\n    // Get the elapsed time in the song\n    const elapsedInSong = elapsed - (currentLength - song.lengthSeconds);\n    return { song, elapsed: elapsedInSong };\n}\n/**\n * We may want to get the next song, previous song, or maybe a song played 4 songs ago.\n *\n * For example, getting the next song would be offset = 1, previous song would be offset = -1, and a song played 4 songs ago would be offset = -4.\n * Automatically wraps around the playlist if necessary.\n */\nexport async function getSongRelative(playlistId, offset) {\n    const songs = await shuffledPlaylistVideos(playlistId);\n    const current = await getCurrentSong(playlistId);\n    // Find the index of the current song\n    let idx = songs.findIndex(s => s.videoId === current.song?.videoId);\n    // Add the offset. Wrap around if necessary\n    idx += offset;\n    idx %= songs.length;\n    return songs[idx];\n}\n", "import { getPlaylistId } from './meta';\nimport { getOptions } from './options';\nimport { getSongRelative } from './radio';\nimport { videoAudioSource } from './youtube';\nexport async function setSongAndTime(song, time) {\n    // Get the audio element\n    const audio = document.getElementById('radio-audio');\n    const src = await videoAudioSource(song.videoId);\n    audio.src = src.url;\n    audio.currentTime = time;\n    audio.play();\n    // Whenever we set the song, we should also preload the next song\n    const nextSong = await getSongRelative(getPlaylistId(), 1);\n    const nextAudio = await videoAudioSource(nextSong.videoId);\n    await preloadSong(nextAudio);\n}\n/**\n * Set the volume and stuff\n */\nexport async function initAudioController() {\n    const audio = document.getElementById('radio-audio');\n    const { volume } = getOptions();\n    audio.volume = volume / 100;\n}\n/**\n * Preload a given song\n */\nexport async function preloadSong(song) {\n    console.log('Caching next song: ', song.url);\n    // Create a disabled audio tag, set the src, and then remove it when it's loaded\n    const audio = document.createElement('audio');\n    audio.src = song.url;\n    audio.preload = 'metadata';\n    const inst = document.body.appendChild(audio);\n    inst.addEventListener('loadeddata', () => {\n        inst.remove();\n    });\n}\n", "import { getOptions, setOption } from './options';\ndocument.addEventListener('DOMContentLoaded', () => {\n    const addOpen = document.getElementById('add-open');\n    const addClose = document.getElementById('add-close');\n    const optionClose = document.getElementById('options-close');\n    addOpen.addEventListener('click', () => {\n        // Get the playlist URL or ID from the input\n        const input = document.getElementById('playlist-input');\n        const radioName = document.getElementById('radio-name-input');\n        const urlOrId = input.value;\n        // If the input is empty, don't do anything\n        if (!urlOrId)\n            return;\n        // If the input is a URL, get the ID from it\n        const url = new URL(urlOrId);\n        const id = url.searchParams.get('list');\n        // If the input is an ID, use it\n        const playlistId = id ?? urlOrId;\n        // Set new window location\n        window.location.search = `?id=${playlistId}&name=${radioName.value}`;\n    });\n    addClose.addEventListener('click', () => {\n        closeModal('add-dialog');\n    });\n    optionClose.addEventListener('click', () => {\n        closeModal('options-dialog');\n    });\n});\nexport function openModal(id) {\n    const diag = document.getElementById(id);\n    diag.showModal();\n}\nexport function closeModal(id) {\n    const diag = document.getElementById(id);\n    diag.close();\n}\nexport function registerButtonHandlers() {\n    // Create dialog event listeners\n    const addButton = document.getElementById('add-icon');\n    const optionsButton = document.getElementById('options-icon');\n    addButton.addEventListener('click', () => {\n        openModal('add-dialog');\n    });\n    optionsButton.addEventListener('click', () => {\n        openModal('options-dialog');\n    });\n    // Also handle the option inputs\n    const inputs = document.querySelectorAll('.option-row input');\n    const selects = document.querySelectorAll('.option-row select');\n    inputs.forEach((input) => {\n        // Inputs have a data-option attribute with the option names\n        const option = input.dataset.option;\n        // Set the input value to the option value\n        // @ts-expect-error We doin something weird\n        input.value = getOptions()[option];\n        // Also setup the event listener to update the option when the input changes\n        input.onchange = () => {\n            // @ts-expect-error We doin something weird\n            setOption(option, input.value);\n        };\n    });\n    selects.forEach((select) => {\n        // Selects have a data-option attribute with the option names\n        const option = select.dataset.option;\n        // Set the select value to the option value\n        // @ts-expect-error We doin something weird\n        select.value = getOptions()[option];\n        // Also setup the event listener to update the option when the select changes\n        select.onchange = () => {\n            // @ts-expect-error We doin something weird\n            setOption(option, select.value);\n        };\n    });\n}\n", "import { setSongAndTime } from './audioController';\nimport { getPlaylistId } from './meta';\nimport { setOption } from './options';\nimport { getCurrentSong } from './radio';\n/**\n * Set volume\n */\nexport function setVolume(volume) {\n    const audio = document.getElementById('radio-audio');\n    const volumeBar = document.querySelector('#volume-bar');\n    const volumeBarLines = volumeBar.querySelectorAll('.volume-bar-line');\n    const volumeNumber = document.querySelector('#volume-number');\n    if (volume < 0)\n        volume = 0;\n    if (volume > 100)\n        volume = 100;\n    volume > 0 ? volumeBar.classList.remove('muted') : volumeBar.classList.add('muted');\n    audio.volume = volume / 100;\n    // Find closest multiple of of however many lines there are\n    const closest = Math.round(volume / (100 / volumeBarLines.length)) * (100 / volumeBarLines.length);\n    // Remove all classes\n    volumeBarLines.forEach(line => line.classList.remove('active'));\n    // Add classes to the closest multiple of the volume bar lines\n    for (let i = 0; i < closest / (100 / volumeBarLines.length); i++) {\n        volumeBarLines[i].classList.add('active');\n    }\n    // Set the volume number\n    volumeNumber.textContent = `${volume}%`;\n    // Set the volume in options\n    setOption('volume', volume);\n}\n/**\n * Create a single-use click listener for the volume bar. Clicking it will trigger the audio element to play\n */\nexport function createTempVolumeListener() {\n    const click = async () => {\n        const { song, elapsed } = await getCurrentSong(getPlaylistId());\n        setSongAndTime(song, elapsed);\n        document.removeEventListener('click', click);\n    };\n    document.addEventListener('click', click);\n}\n// Event listener for dragging/clicking on the volume bar\ndocument.addEventListener('DOMContentLoaded', () => {\n    const volumeBar = document.querySelector('#volume-bar');\n    volumeBar.addEventListener('click', e => {\n        const evt = e;\n        const volume = Math.floor((evt.offsetX / volumeBar.clientWidth) * 100);\n        setVolume(volume);\n    });\n    volumeBar.addEventListener('mousedown', (e) => {\n        const evt = e;\n        const volume = Math.floor((evt.offsetX / volumeBar.clientWidth) * 100);\n        setVolume(volume);\n        document.addEventListener('mousemove', mouseMove);\n        document.addEventListener('mouseup', mouseUp);\n    });\n    const mouseMove = (e) => {\n        const evt = e;\n        // target needs to be the volumeBar\n        if (evt.target !== volumeBar)\n            return;\n        const volume = Math.floor((evt.offsetX / volumeBar.clientWidth) * 100);\n        setVolume(volume);\n    };\n    const mouseUp = () => {\n        document.removeEventListener('mousemove', mouseMove);\n        document.removeEventListener('mouseup', mouseUp);\n    };\n});\n", "export function activateVolumeFade() {\n    // When the #volume element is hovered, show it all for a few seconds, then fade it out\n    const volume = document.querySelector('#volume');\n    const show = () => {\n        volume.classList.remove('hide');\n    };\n    const fade = () => {\n        volume.classList.add('hide');\n    };\n    // Hide the volume bar by default\n    fade();\n    volume.addEventListener('mouseenter', show);\n    volume.addEventListener('mouseleave', fade);\n}\n", "import { initAudioController, setSongAndTime } from './util/audioController';\nimport { registerButtonHandlers } from './util/dialogs';\nimport { getPlaylistId, getRadioName } from './util/meta';\nimport { getCurrentSong } from './util/radio';\nimport { createTempVolumeListener, setVolume } from './util/volume';\nimport { activateVolumeFade } from './util/volumeFade';\nimport { playlistVideos } from './util/youtube';\n// OBS overlay flag\nconst isObs = new URLSearchParams(window.location.search).get('obs') === 'true';\n// Change the meta tags to reflect the playlist, if there is one\nif (getPlaylistId() && getRadioName()) {\n    const name = getRadioName();\n    const titles = document.querySelectorAll('meta[name*=\"title\"]');\n    const descriptions = document.querySelectorAll('meta[name*=\"description\"]');\n    for (const title of titles) {\n        title.setAttribute('content', 'Titune');\n    }\n    for (const description of descriptions) {\n        description.setAttribute('content', `Listen along to \"${name}\" Radio`);\n    }\n}\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // If we're in OBS, add transparent class to HTML\n    if (isObs) {\n        document.documentElement.classList.add('transparent');\n        activateVolumeFade();\n    }\n    registerButtonHandlers();\n    // Every second, update currently-playing and time-elapsed\n    const currentlyPlaying = document.getElementById('currently-playing');\n    const timeElapsed = document.getElementById('time-elapsed');\n    const songLength = document.getElementById('duration');\n    const cover = document.getElementById('cover');\n    const playlistId = getPlaylistId();\n    let identifier = '';\n    // Set page title to Titune | <radio name>\n    const radioName = getRadioName();\n    document.title = radioName ? `Titune | ${radioName}` : 'Titune';\n    initAudioController();\n    // in order to prompt the user to interact with the page, allowing us to play(), we set volume to 0\n    setVolume(0);\n    createTempVolumeListener();\n    // Ensure we call this at least once, to cache the playlist\n    if (!playlistId) {\n        // Set the song name to something helpful\n        currentlyPlaying.textContent = 'Create a radio from the top left!';\n        return;\n    }\n    await playlistVideos(playlistId);\n    setInterval(async () => {\n        const { song, elapsed } = await getCurrentSong(playlistId);\n        // If the song changes, set the new song and timestamp\n        if (!identifier.includes(song?.title ?? 'Unknown') && song) {\n            const arrayInArrayMaybe = song.videoThumbnails.length > 0 && Array.isArray(song.videoThumbnails[0]) ? song.videoThumbnails[0] : song.videoThumbnails;\n            // @ts-expect-error This array stuff is funky\n            const highestWidthThumb = arrayInArrayMaybe.reduce((prev, curr) => curr.width > prev.width ? curr : prev).url;\n            cover.setAttribute('src', highestWidthThumb);\n            // Also set the body background to the cover\n            const bgCover = document.getElementById('bg-cover');\n            bgCover.style.backgroundImage = `url(${highestWidthThumb})`;\n            // ALSO set the favicon to the cover\n            const favicon = document.getElementById('favicon');\n            favicon.setAttribute('href', highestWidthThumb);\n            setSongAndTime(song, elapsed);\n        }\n        // Prevents rapid DOM updates\n        if (`${song?.title ?? 'Unknown'}${elapsed}` === identifier) {\n            return;\n        }\n        currentlyPlaying.textContent = song?.title ?? 'Unknown';\n        timeElapsed.textContent = `${Math.floor(elapsed / 60)}:${Math.floor(elapsed % 60).toString().padStart(2, '0')}`;\n        songLength.textContent = `${Math.floor((song?.lengthSeconds ?? 0) / 60)}:${Math.floor((song?.lengthSeconds ?? 0) % 60).toString().padStart(2, '0')}`;\n        // Set the progress bar inners width to reflect the percentage of the song that has elapsed\n        const progressBarInner = document.getElementById('progress-bar-fill');\n        const songPct = (elapsed / (song?.lengthSeconds ?? 1)) * 100;\n        progressBarInner.style.width = `${songPct}%`;\n        identifier = `${song?.title ?? 'Unknown'}${elapsed}`;\n    }, 200);\n});\n"],
  "mappings": "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",
  "names": ["getRadioName", "getPlaylistId", "qualityList", "defaultOptions", "getOptions", "options", "setOption", "o", "v", "cachedPlaylistVideos", "playlistVideos", "playlistId", "cachedPlaylistVideos", "inst", "getOptions", "url", "result", "r", "videoAudioSources", "videoId", "videoAudioSource", "sources", "preferredCodec", "codecPreferred", "s", "sourceWithClosestQuality", "maxQuality", "qualities", "qualityList", "q", "a", "b", "shuffledPlaylistVideos", "videos", "seed", "seedFromPlaylistId", "now", "totalLength", "prev", "curr", "dynSeed", "shuffle", "array", "shuffled", "i", "j", "temp", "seedFromPlaylistId", "playlistId", "seed", "i", "getCurrentSong", "songs", "shuffledPlaylistVideos", "now", "totalLength", "song", "elapsed", "currentLength", "s", "elapsedInSong", "getSongRelative", "offset", "current", "idx", "setSongAndTime", "song", "time", "audio", "src", "videoAudioSource", "nextSong", "getSongRelative", "getPlaylistId", "nextAudio", "preloadSong", "initAudioController", "volume", "getOptions", "inst", "addOpen", "addClose", "optionClose", "input", "radioName", "urlOrId", "playlistId", "closeModal", "openModal", "id", "registerButtonHandlers", "addButton", "optionsButton", "inputs", "selects", "option", "getOptions", "setOption", "select", "setVolume", "volume", "audio", "volumeBar", "volumeBarLines", "volumeNumber", "closest", "line", "i", "setOption", "createTempVolumeListener", "click", "song", "elapsed", "getCurrentSong", "getPlaylistId", "setSongAndTime", "e", "mouseMove", "mouseUp", "evt", "activateVolumeFade", "volume", "show", "fade", "isObs", "getPlaylistId", "getRadioName", "name", "titles", "descriptions", "title", "description", "activateVolumeFade", "registerButtonHandlers", "currentlyPlaying", "timeElapsed", "songLength", "cover", "playlistId", "identifier", "radioName", "initAudioController", "setVolume", "createTempVolumeListener", "playlistVideos", "song", "elapsed", "getCurrentSong", "highestWidthThumb", "prev", "curr", "bgCover", "setSongAndTime", "progressBarInner", "songPct"]
}
